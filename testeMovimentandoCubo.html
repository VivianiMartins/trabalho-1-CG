<!DOCTYPE html>
<html>
    <head>
        <meta charset="UTF-8">
        <title>Cena WebGL - Reflexo e Movimento</title>

        <script type="text/javascript" src="Common/MV.js"></script>
        <script type="text/javascript" src="Common/initShaders.js"></script>

        <script type="vertex" id="vs-main">
            #version 300 es

            // Atributos (Dados únicos de cada vértice)
            in vec4 aPosition;
            in vec3 aNormal;
            in vec2 aTexCoord;

            // Uniforms (Dados globais para todos os vértices)
            uniform mat4 uModelMatrix;      // Move/Gira/Escala o objeto
            uniform mat4 uViewMatrix;       // Posiciona a câmera
            uniform mat4 uProjectionMatrix; // Aplica a perspectiva (lente)
            uniform float uNormalScaleY;    // Usado para inverter a normal no reflexo

            // Saídas para o Fragment Shader (Interpoladas)
            out vec3 vNormal;
            out vec3 vWorldPos;
            out vec2 vTexCoord;

            void main() {
                // 1. Calcula a posição do vértice no mundo 3D
                vec4 worldPosition = uModelMatrix * aPosition;
                vWorldPos = worldPosition.xyz;

                // 2. Calcula a normal corrigida (Rotacionada junto com o objeto)
                // O mat3 remove a translação, mantendo apenas rotação/escala
                vec3 N = mat3(uModelMatrix) * aNormal;

                // Ajusta a normal se estivermos desenhando o reflexo (invertendo Z/Y relativo)
                vNormal = normalize(N * vec3(1.0, 1.0, uNormalScaleY));

                // 3. Passa a coordenada de textura
                vTexCoord = aTexCoord;

                // 4. Define a posição final na tela (Clip Space)
                gl_Position = uProjectionMatrix * uViewMatrix * worldPosition;
            }
        </script>

        <script type="fragment" id="fs-main">
            #version 300 es
            precision highp float;

            // Entradas vindas do Vertex Shader
            in vec3 vNormal;
            in vec3 vWorldPos;
            in vec2 vTexCoord;

            // Configurações da Cena
            uniform vec3 uCameraPosition;
            uniform int uObjectType;         // 0 = Espelho, 1 = Objeto Sólido

            // Clipping (Corte) para o reflexo
            uniform bool uUseClippingPlane;
            uniform vec4 uClipPlaneEquation; // Define o plano matemático de corte

            // Iluminação
            uniform vec3 uLightPosition;
            uniform vec3 uAmbientColor;
            uniform vec3 uDiffuseColor;
            uniform vec3 uSpecularColor;
            uniform float uShininess;

            // Materiais
            uniform float uTransparencyLevel;
            uniform sampler2D uMainTextureSampler;

            out vec4 finalFragmentColor;

            void main() {
                // === LÓGICA DE CORTE (Clipping) ===
                // Se o pixel estiver "atrás" do espelho durante o reflexo, não desenha.
                if (uUseClippingPlane) {
                    if (dot(vec4(vWorldPos, 1.0), uClipPlaneEquation) < 0.0) discard;
                }

                // Vetores de Iluminação
                vec3 N = normalize(vNormal);
                vec3 V = normalize(uCameraPosition - vWorldPos); // Vetor Visão
                vec3 L = normalize(uLightPosition - vWorldPos);  // Vetor Luz

                // === TIPO 1: OBJETOS SÓLIDOS (Cubos) ===
                if (uObjectType == 1) {
                    vec3 ambient = uAmbientColor;

                    // Difusa (Lambert)
                    float diffFactor = max(dot(N, L), 0.0);
                    vec3 diffuse = uDiffuseColor * diffFactor;

                    // Especular (Phong)
                    vec3 R = reflect(-L, N);
                    float specFactor = pow(max(dot(V, R), 0.0), uShininess);
                    vec3 specular = uSpecularColor * specFactor;

                    // Textura
                    vec4 texColor = texture(uMainTextureSampler, vTexCoord);

                    // Combina Luz + Textura
                    vec3 lighting = (ambient + diffuse) * texColor.rgb + specular;

                    finalFragmentColor = vec4(lighting, 1.0);
                    return;
                }

                // === TIPO 0: ESPELHO / VIDRO ===
                if (uObjectType == 0) {
                    if (gl_FrontFacing) {
                        vec4 texColor = texture(uMainTextureSampler, vTexCoord);

                        // Brilho especular no vidro
                        vec3 H = normalize(L + V);
                        float spec = pow(max(dot(N, H), 0.0), 128.0);

                        // Efeito Fresnel: Vidro fica mais opaco/reflexivo em ângulos rasos
                        float fresnel = pow(1.0 - max(dot(V, N), 0.0), 2.0);

                        // Mistura a transparência do slider com o Fresnel
                        float finalAlpha = clamp(uTransparencyLevel + (fresnel * 0.3), 0.0, 1.0);

                        vec3 finalRGB = texColor.rgb + (uSpecularColor * spec);

                        finalFragmentColor = vec4(finalRGB, finalAlpha);
                    }
                    else {
                        // Parte de trás do vidro (iluminação básica)
                        vec3 backN = -N;
                        float diff = max(dot(backN, L), 0.0);
                        vec3 solidColor = vec3(0.533, 0.533, 0.792);
                        vec3 lighting = uAmbientColor * solidColor + uDiffuseColor * diff * solidColor;
                        finalFragmentColor = vec4(lighting, 1.0);
                    }
                }
            }
        </script>
    </head>

    <body style="margin: 0; overflow: hidden; background-color: #000;">
        <canvas id="gl-canvas"></canvas>

        <div style="position: absolute; top: 10px; left: 10px; color: white; font-family: sans-serif; pointer-events: none; background-color: rgb(57, 52, 50); padding: 10px; border-radius: 8px; ">
            <b>Controles:</b><br>
            <span style="color: cyan;">W / S / A / D</span> -> Mover Câmera <br>
            Mouse -> Olhar (Clique para travar) <br>
            <hr style="opacity: 0.5;">
            <span style="color: lime;">Setas (↑ ↓ ← →)</span> -> Mover Cubo <br>
            <hr style="opacity: 0.5;">
            <label for="alphaSlider" style="pointer-events: auto;">
                Opacidade espelho: <span id="valDisplay" style="color: yellow;">40%</span>
            </label><br>
            <input type="range" id="alphaSlider" min="0.0" max="1.0" step="0.01" value="0.4" style="pointer-events: auto; width: 100%;">
        </div>

        <img id="tex-cubo-pedra" src="resources/freepbr/concrete3-albedo.png" hidden onerror="this.src='https://via.placeholder.com/512/808080/FFFFFF?text=Pedra'"/>
        <img id="tex-cubo-colorido" src="resources/cube.png" hidden onerror="this.src='https://via.placeholder.com/512/654321/FFFFFF?text=Colorido'"/>
        <img id="tex-vidro" src="resources/vidro.png" hidden onerror="this.src='https://via.placeholder.com/512/00FFFF/FFFFFF?text=Vidro'"/>

        <script type="text/javascript">
            // --- Variáveis Globais (Contexto e Shader) ---
            let webGLContext;
            let shaderProgram;
            let canvasElement;

            // --- Locais das Variáveis no Shader (Uniforms) ---
            // Matrizes
            let uModelMatrixLoc, uViewMatrixLoc, uProjectionMatrixLoc, uNormalScaleLoc;
            // Câmera e Objetos
            let uCameraPosLoc, uObjectTypeLoc, uMainTextureLoc;
            // Luz
            let uLightPosLoc, uAmbientLightLoc, uDiffuseLightLoc, uSpecularLightLoc, uShininessLoc;
            // Clipping e Transparência
            let uUseClipLoc, uClipPlaneLoc, uTransparencyLoc;

            // Estado da Aplicação
            let currentTransparency = 0.4;
            let activeKeysState = {}; // Guarda quais teclas estão pressionadas
            let lastTime = 0;         // Para calcular Delta Time

            // Dados das Geometrias (Buffers)
            let cubeGeometryInfo, glassPlaneGeometryInfo;

            // Texturas WebGL
            let textureStoneCube, textureColoredCube, textureGlass;

            // Posição inicial do Cubo Móvel
            let movableCubePosition = vec3(-3.0, 1.0, 10.0);
            const CUBE_MOVE_SPEED = 15.0;

            // Estado da Câmera
            let camera = {
                pos: vec3(0.0, 5.0, 25.0),
                pitch: -10.0,
                yaw: -90.0,
                speed: 10.0,
                mouseSensitivity: 0.1,
                turnSpeed: 100.0
            };

            const MIRROR_Z_POSITION = 0.0;

            // Configuração de Iluminação
            const lightConfig = {
                pos: vec3(10.0, 10.0, 20.0),
                ambient: vec3(0.2, 0.2, 0.2),
                diffuse: vec3(0.9, 0.9, 0.9),
                specular: vec3(1.0, 1.0, 1.0),
                shininess: 60.0
            };

            // --- Inicialização ---
            window.onload = function init() {
                canvasElement = document.getElementById("gl-canvas");
                if (!canvasElement) return;

                canvasElement.width = window.innerWidth;
                canvasElement.height = window.innerHeight;

                // Inicializa o WebGL 2 com suporte a Stencil Buffer (Crucial para o espelho)
                webGLContext = canvasElement.getContext("webgl2", { stencil: true });
                if (!webGLContext) { alert("WebGL 2.0 necessário"); return; }

                // Ativa teste de profundidade e transparência (Blending)
                webGLContext.enable(webGLContext.DEPTH_TEST);
                webGLContext.enable(webGLContext.BLEND);
                webGLContext.blendFunc(webGLContext.SRC_ALPHA, webGLContext.ONE_MINUS_SRC_ALPHA);

                // Compila Shaders
                shaderProgram = initShaders(webGLContext, "vs-main", "fs-main");
                webGLContext.useProgram(shaderProgram);

                // Mapeia as variáveis do Javascript para o GLSL
                mapShaderLocations();

                // Cria os objetos 3D
                createGeometries();

                // Carrega Texturas
                textureStoneCube = loadTexture("tex-cubo-pedra");
                textureColoredCube = loadTexture("tex-cubo-colorido");
                textureGlass = loadTexture("tex-vidro");

                // Configura inputs
                setupInputListeners();
                setupSlider();

                // Inicia loop
                requestAnimationFrame(renderSceneLoop);
            };

            window.onresize = function() {
                if (canvasElement) {
                    canvasElement.width = window.innerWidth;
                    canvasElement.height = window.innerHeight;
                    webGLContext.viewport(0, 0, canvasElement.width, canvasElement.height);
                }
            };

            // Função auxiliar para organizar o mapeamento de variáveis
            function mapShaderLocations() {
                uModelMatrixLoc = webGLContext.getUniformLocation(shaderProgram, "uModelMatrix");
                uViewMatrixLoc = webGLContext.getUniformLocation(shaderProgram, "uViewMatrix");
                uProjectionMatrixLoc = webGLContext.getUniformLocation(shaderProgram, "uProjectionMatrix");
                uNormalScaleLoc = webGLContext.getUniformLocation(shaderProgram, "uNormalScaleY");

                uUseClipLoc = webGLContext.getUniformLocation(shaderProgram, "uUseClippingPlane");
                uClipPlaneLoc = webGLContext.getUniformLocation(shaderProgram, "uClipPlaneEquation");

                uCameraPosLoc = webGLContext.getUniformLocation(shaderProgram, "uCameraPosition");
                uObjectTypeLoc = webGLContext.getUniformLocation(shaderProgram, "uObjectType");
                uMainTextureLoc = webGLContext.getUniformLocation(shaderProgram, "uMainTextureSampler");

                uLightPosLoc = webGLContext.getUniformLocation(shaderProgram, "uLightPosition");
                uAmbientLightLoc = webGLContext.getUniformLocation(shaderProgram, "uAmbientColor");
                uDiffuseLightLoc = webGLContext.getUniformLocation(shaderProgram, "uDiffuseColor");
                uSpecularLightLoc = webGLContext.getUniformLocation(shaderProgram, "uSpecularColor");
                uShininessLoc = webGLContext.getUniformLocation(shaderProgram, "uShininess");

                uTransparencyLoc = webGLContext.getUniformLocation(shaderProgram, "uTransparencyLevel");
            }

            // Carrega textura e cria mipmaps
            function loadTexture(elementId) {
                let tex = webGLContext.createTexture();
                webGLContext.bindTexture(webGLContext.TEXTURE_2D, tex);
                // Pixel azul temporário
                webGLContext.texImage2D(webGLContext.TEXTURE_2D, 0, webGLContext.RGBA, 1, 1, 0, webGLContext.RGBA, webGLContext.UNSIGNED_BYTE, new Uint8Array([100,100,255,255]));

                let img = document.getElementById(elementId);
                let upload = () => {
                    webGLContext.bindTexture(webGLContext.TEXTURE_2D, tex);
                    webGLContext.texImage2D(webGLContext.TEXTURE_2D, 0, webGLContext.RGBA, webGLContext.RGBA, webGLContext.UNSIGNED_BYTE, img);
                    webGLContext.generateMipmap(webGLContext.TEXTURE_2D);
                };

                if(img.complete && img.naturalWidth > 0) upload(); else img.onload = upload;
                return tex;
            }

            // Define vértices e cria buffers
            function createGeometries() {
                // --- Geometria do Cubo ---
                let cubeVerts = [
                    vec4(-0.5,-0.5,0.5,1), vec4(0.5,-0.5,0.5,1), vec4(0.5,0.5,0.5,1), vec4(-0.5,-0.5,0.5,1), vec4(0.5,0.5,0.5,1), vec4(-0.5,0.5,0.5,1),
                    vec4(-0.5,-0.5,-0.5,1), vec4(-0.5,0.5,-0.5,1), vec4(0.5,0.5,-0.5,1), vec4(-0.5,-0.5,-0.5,1), vec4(0.5,0.5,-0.5,1), vec4(0.5,-0.5,-0.5,1),
                    vec4(-0.5,0.5,-0.5,1), vec4(-0.5,0.5,0.5,1), vec4(0.5,0.5,0.5,1), vec4(-0.5,0.5,-0.5,1), vec4(0.5,0.5,0.5,1), vec4(0.5,0.5,-0.5,1),
                    vec4(-0.5,-0.5,-0.5,1), vec4(0.5,-0.5,-0.5,1), vec4(0.5,-0.5,0.5,1), vec4(-0.5,-0.5,-0.5,1), vec4(0.5,-0.5,0.5,1), vec4(-0.5,-0.5,0.5,1),
                    vec4(0.5,-0.5,-0.5,1), vec4(0.5,0.5,-0.5,1), vec4(0.5,0.5,0.5,1), vec4(0.5,-0.5,-0.5,1), vec4(0.5,0.5,0.5,1), vec4(0.5,-0.5,0.5,1),
                    vec4(-0.5,-0.5,-0.5,1), vec4(-0.5,-0.5,0.5,1), vec4(-0.5,0.5,0.5,1), vec4(-0.5,-0.5,-0.5,1), vec4(-0.5,0.5,0.5,1), vec4(-0.5,0.5,-0.5,1)
                ];
                let cubeNormals = [
                    vec3(0,0,1),vec3(0,0,1),vec3(0,0,1),vec3(0,0,1),vec3(0,0,1),vec3(0,0,1),
                    vec3(0,0,-1),vec3(0,0,-1),vec3(0,0,-1),vec3(0,0,-1),vec3(0,0,-1),vec3(0,0,-1),
                    vec3(0,1,0),vec3(0,1,0),vec3(0,1,0),vec3(0,1,0),vec3(0,1,0),vec3(0,1,0),
                    vec3(0,-1,0),vec3(0,-1,0),vec3(0,-1,0),vec3(0,-1,0),vec3(0,-1,0),vec3(0,-1,0),
                    vec3(1,0,0),vec3(1,0,0),vec3(1,0,0),vec3(1,0,0),vec3(1,0,0),vec3(1,0,0),
                    vec3(-1,0,0),vec3(-1,0,0),vec3(-1,0,0),vec3(-1,0,0),vec3(-1,0,0),vec3(-1,0,0)
                ];
                // Mapeia a textura para cobrir cada face (0 a 1)
                let cubeUVs = []; for(let i=0; i<6; i++) cubeUVs.push(vec2(0,0),vec2(1,0),vec2(1,1),vec2(0,0),vec2(1,1),vec2(0,1));

                cubeGeometryInfo = createBufferInfo(cubeVerts, cubeNormals, cubeUVs);

                // --- Geometria do Plano (Espelho) ---
                let planeVerts = [ vec4(-10,-6,0,1), vec4(10,-6,0,1), vec4(10,6,0,1), vec4(-10,-6,0,1), vec4(10,6,0,1), vec4(-10,6,0,1) ];
                let planeNormals = [ vec3(0,0,1), vec3(0,0,1), vec3(0,0,1), vec3(0,0,1), vec3(0,0,1), vec3(0,0,1) ];
                let planeUVs = [ vec2(0,0), vec2(1,0), vec2(1,1), vec2(0,0), vec2(1,1), vec2(0,1) ];

                glassPlaneGeometryInfo = createBufferInfo(planeVerts, planeNormals, planeUVs);
            }

            // Cria VBOs (Dados) e encapsula no VAO (Configuração)
            function createBufferInfo(positions, normals, uvs) {
                let vao = webGLContext.createVertexArray();
                webGLContext.bindVertexArray(vao);

                // Buffer de Posição
                let posBuffer = webGLContext.createBuffer();
                webGLContext.bindBuffer(webGLContext.ARRAY_BUFFER, posBuffer);
                webGLContext.bufferData(webGLContext.ARRAY_BUFFER, flatten(positions), webGLContext.STATIC_DRAW);
                // "aPosition" é o nome no Vertex Shader
                let posLoc = webGLContext.getAttribLocation(shaderProgram, "aPosition");
                webGLContext.vertexAttribPointer(posLoc, 4, webGLContext.FLOAT, false, 0, 0);
                webGLContext.enableVertexAttribArray(posLoc);

                // Buffer de Normal
                let normBuffer = webGLContext.createBuffer();
                webGLContext.bindBuffer(webGLContext.ARRAY_BUFFER, normBuffer);
                webGLContext.bufferData(webGLContext.ARRAY_BUFFER, flatten(normals), webGLContext.STATIC_DRAW);
                let normLoc = webGLContext.getAttribLocation(shaderProgram, "aNormal");
                webGLContext.vertexAttribPointer(normLoc, 3, webGLContext.FLOAT, false, 0, 0);
                webGLContext.enableVertexAttribArray(normLoc);

                // Buffer de Coordenadas de Textura
                let uvBuffer = webGLContext.createBuffer();
                webGLContext.bindBuffer(webGLContext.ARRAY_BUFFER, uvBuffer);
                webGLContext.bufferData(webGLContext.ARRAY_BUFFER, flatten(uvs), webGLContext.STATIC_DRAW);
                let uvLoc = webGLContext.getAttribLocation(shaderProgram, "aTexCoord");
                webGLContext.vertexAttribPointer(uvLoc, 2, webGLContext.FLOAT, false, 0, 0);
                webGLContext.enableVertexAttribArray(uvLoc);

                webGLContext.bindVertexArray(null);
                return { vao: vao, count: positions.length };
            }

            // Auxiliares Matemáticos
            function scaleVec(s, v) { return vec3(v[0]*s, v[1]*s, v[2]*s); }
            function radians(deg) { return deg * Math.PI / 180.0; }

            function setupInputListeners() {
                document.addEventListener('keydown', (e) => activeKeysState[e.code] = true);
                document.addEventListener('keyup', (e) => activeKeysState[e.code] = false);

                canvasElement.onclick = () => canvasElement.requestPointerLock();

                document.addEventListener('mousemove', (e) => {
                    if (document.pointerLockElement === canvasElement) {
                        camera.yaw += e.movementX * camera.mouseSensitivity;
                        camera.pitch -= e.movementY * camera.mouseSensitivity;
                        // Limita para não girar a câmera de cabeça para baixo
                        if(camera.pitch > 89) camera.pitch = 89;
                        if(camera.pitch < -89) camera.pitch = -89;
                    }
                });
            }

            function setupSlider() {
                const slider = document.getElementById("alphaSlider");
                const display = document.getElementById("valDisplay");
                const updateText = (val) => {
                    let percent = Math.round(val * 100);
                    display.innerText = percent + "%";
                };
                updateText(slider.value);
                slider.addEventListener("input", function(e) {
                    let val = parseFloat(e.target.value);
                    currentTransparency = val;
                    updateText(val);
                });
            }

            // Atualiza posição do cubo móvel (Setas)
            function processCubeMovement(dt) {
                let speed = CUBE_MOVE_SPEED * dt;
                if (activeKeysState['ArrowUp']) movableCubePosition[2] -= speed;
                if (activeKeysState['ArrowDown']) movableCubePosition[2] += speed;
                if (activeKeysState['ArrowLeft']) movableCubePosition[0] -= speed;
                if (activeKeysState['ArrowRight']) movableCubePosition[0] += speed;
            }

            // Atualiza posição da câmera (WASD + Q/E)
            function processCameraMovement(dt) {
                if (activeKeysState['KeyQ']) camera.yaw -= camera.turnSpeed * dt;
                if (activeKeysState['KeyE']) camera.yaw += camera.turnSpeed * dt;

                let front = normalize(vec3(
                    Math.cos(radians(camera.yaw))*Math.cos(radians(camera.pitch)),
                    Math.sin(radians(camera.pitch)),
                    Math.sin(radians(camera.yaw))*Math.cos(radians(camera.pitch))
                ));
                let right = normalize(cross(front, vec3(0,1,0)));
                let vel = camera.speed * dt;

                if (activeKeysState['KeyW']) camera.pos = add(camera.pos, scaleVec(vel, front));
                if (activeKeysState['KeyS']) camera.pos = subtract(camera.pos, scaleVec(vel, front));
                if (activeKeysState['KeyA']) camera.pos = subtract(camera.pos, scaleVec(vel, right));
                if (activeKeysState['KeyD']) camera.pos = add(camera.pos, scaleVec(vel, right));

                return front;
            }

            // Renderiza os objetos sólidos da cena
            function drawSolidObjects(time, scaleVector, useClipping) {
                webGLContext.uniform1i(uObjectTypeLoc, 1); // 1 = Sólido
                webGLContext.uniform1f(uNormalScaleLoc, scaleVector[2]); // Inverte normal se Z for -1
                webGLContext.uniform1i(uUseClipLoc, useClipping ? 1 : 0);

                if (useClipping) webGLContext.uniform4f(uClipPlaneLoc, 0.0, 0.0, -1.0, 0.05);

                // Matriz de escala (usada para espelhar o mundo)
                let transformMatrix = scale(scaleVector[0], scaleVector[1], scaleVector[2]);

                // 1. Cubo Colorido (Móvel)
                webGLContext.activeTexture(webGLContext.TEXTURE0);
                webGLContext.bindTexture(webGLContext.TEXTURE_2D, textureColoredCube);
                webGLContext.uniform1i(uMainTextureLoc, 0);

                // Aplica Transformações
                let m1 = mult(transformMatrix, mult(translate(movableCubePosition[0], movableCubePosition[1], movableCubePosition[2]), mult(rotateY(time * 30), scale(2, 2, 2))));
                webGLContext.uniformMatrix4fv(uModelMatrixLoc, false, flatten(m1));

                webGLContext.bindVertexArray(cubeGeometryInfo.vao);
                webGLContext.drawArrays(webGLContext.TRIANGLES, 0, cubeGeometryInfo.count);

                // 2. Cubo de Pedra (Fundo Estático)
                webGLContext.bindTexture(webGLContext.TEXTURE_2D, textureStoneCube);
                let m2 = mult(transformMatrix, mult(translate(3, -10, -150), mult(rotateX(time * 10), scale(10, 10, 10))));
                webGLContext.uniformMatrix4fv(uModelMatrixLoc, false, flatten(m2));
                webGLContext.drawArrays(webGLContext.TRIANGLES, 0, cubeGeometryInfo.count);

                webGLContext.uniform1i(uUseClipLoc, 0);
            }

            // Renderiza o plano do vidro/espelho
            function drawMirrorPlane() {
                webGLContext.uniform1i(uObjectTypeLoc, 0); // 0 = Vidro
                webGLContext.uniform1f(uNormalScaleLoc, 1.0);
                webGLContext.uniform1i(uUseClipLoc, 0);
                webGLContext.uniform1f(uTransparencyLoc, currentTransparency);

                webGLContext.activeTexture(webGLContext.TEXTURE0);
                webGLContext.bindTexture(webGLContext.TEXTURE_2D, textureGlass);
                webGLContext.uniform1i(uMainTextureLoc, 0);

                webGLContext.uniformMatrix4fv(uModelMatrixLoc, false, flatten(translate(0, 0, MIRROR_Z_POSITION)));
                webGLContext.bindVertexArray(glassPlaneGeometryInfo.vao);
                webGLContext.drawArrays(webGLContext.TRIANGLES, 0, glassPlaneGeometryInfo.count);
            }

            // === Loop Principal de Renderização ===
            function renderSceneLoop(time) {
                time *= 0.001; // ms -> segundos
                let dt = time - lastTime;
                lastTime = time;

                processCubeMovement(dt);
                let front = processCameraMovement(dt);

                // Atualiza Câmera e Projeção
                let viewMatrix = lookAt(camera.pos, add(camera.pos, front), vec3(0,1,0));
                let projMatrix = perspective(60, canvasElement.width / canvasElement.height, 0.1, 1000.0);

                webGLContext.uniformMatrix4fv(uViewMatrixLoc, false, flatten(viewMatrix));
                webGLContext.uniformMatrix4fv(uProjectionMatrixLoc, false, flatten(projMatrix));

                // Envia dados de Iluminação
                webGLContext.uniform3fv(uCameraPosLoc, flatten(camera.pos));
                webGLContext.uniform3fv(uLightPosLoc, flatten(lightConfig.pos));
                webGLContext.uniform3fv(uAmbientLightLoc, flatten(lightConfig.ambient));
                webGLContext.uniform3fv(uDiffuseLightLoc, flatten(lightConfig.diffuse));
                webGLContext.uniform3fv(uSpecularLightLoc, flatten(lightConfig.specular));
                webGLContext.uniform1f(uShininessLoc, lightConfig.shininess);

                webGLContext.clearColor(0.05, 0.05, 0.05, 1.0);
                webGLContext.clear(webGLContext.COLOR_BUFFER_BIT | webGLContext.DEPTH_BUFFER_BIT | webGLContext.STENCIL_BUFFER_BIT);

                //

                // --- PASSO 1: MÁSCARA DE STENCIL ---
                // Desenha o espelho apenas na memória Stencil (invisível)
                // Onde o espelho existe, o valor do stencil vira 1.
                webGLContext.enable(webGLContext.STENCIL_TEST);
                webGLContext.stencilFunc(webGLContext.ALWAYS, 1, 0xFF);
                webGLContext.stencilOp(webGLContext.KEEP, webGLContext.KEEP, webGLContext.REPLACE);
                webGLContext.colorMask(false, false, false, false); // Trava escrita de cor
                webGLContext.depthMask(false);

                webGLContext.enable(webGLContext.CULL_FACE);
                webGLContext.cullFace(webGLContext.BACK);
                drawMirrorPlane();
                webGLContext.disable(webGLContext.CULL_FACE);

                // --- PASSO 2: DESENHO DO REFLEXO ---
                // Desenha os objetos apenas onde Stencil == 1
                webGLContext.stencilFunc(webGLContext.EQUAL, 1, 0xFF);
                webGLContext.stencilOp(webGLContext.KEEP, webGLContext.KEEP, webGLContext.KEEP);
                webGLContext.colorMask(true, true, true, true); // Destrava cor
                webGLContext.depthMask(true);

                // Como o espelhamento é feito invertendo Z (-1), os polígonos ficam do avesso.
                // Invertemos a ordem de leitura (CW = Clockwise) para corrigir.
                webGLContext.frontFace(webGLContext.CW);

                // Desenha objetos com escala Z = -1 (Mundo Invertido)
                drawSolidObjects(time, vec3(1.0, 1.0, -1.0), true);

                webGLContext.frontFace(webGLContext.CCW); // Retorna ao normal

                // --- PASSO 3: DESENHO DO MUNDO REAL ---
                // Desativa o stencil para desenhar o resto da cena normalmente
                webGLContext.disable(webGLContext.STENCIL_TEST);
                drawSolidObjects(time, vec3(1.0, 1.0, 1.0), false);

                // --- PASSO 4: SUPERFÍCIE DO VIDRO ---
                // Desenha o vidro semitransparente por cima do reflexo para dar acabamento
                webGLContext.enable(webGLContext.BLEND);
                drawMirrorPlane();

                requestAnimationFrame(renderSceneLoop);
            }
        </script>
    </body>
</html>